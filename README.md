# Basic Components

This section covers several foundational building blocks commonly used in large-scale distributed systems and location-based services. These topics frequently appear in system design interviews.

---

## Consistent Hashing

**Purpose**  
Distribute data across multiple servers while minimizing data movement when servers are added or removed.

**Core Idea**  
Consistent hashing maps both **servers** and **data keys** into the same hash space, typically represented as a virtual ring.

**How It Works**

- A **virtual hash ring** is defined with a large hash space, for example:
    - `0` to `2^32 - 1`
- Each **server** is hashed onto the ring (commonly using its IP address or hostname).
- Each **data key** is also hashed onto the same ring.
- To locate the server for a given key:
- Move **clockwise** on the ring from the key’s position.
- The **first server encountered** owns that key.

***Virtual Nodes***

> Virtual nodes are a common *engineering optimization* used in practical consistent hashing implementations.

***Why Virtual Nodes Are Used***

If each physical server is hashed only once, the resulting ring may have uneven gaps, leading to **load imbalance**. Some servers may end up owning disproportionately large portions of the key space.

Virtual nodes solve this problem by improving statistical load distribution.

***What Is a Virtual Node?***

- A **virtual node (vnode)** is a **logical entry** on the hash ring.
- Each physical server is represented by **multiple virtual nodes**.
- All virtual nodes belonging to the same physical server ultimately route to that server.
- Virtual nodes do **not** correspond to real machines or processes; they exist only in routing metadata.

***How Virtual Nodes Are Created***

Each virtual node is generated by hashing a **deterministic identifier** derived from the physical server plus an index.

Example (for one server):

```text
IP:Port:VirtualNodeIndex

10.0.1.7:11211#0
10.0.1.7:11211#1
10.0.1.7:11211#2
...
10.0.1.7:11211#99
```
**Why It Matters**
- Adding or removing a server only affects a small fraction of keys.
- Widely used in distributed caches, storage systems, and CDNs.

---

## Proximity Algorithms

Proximity algorithms are used to efficiently query or route based on geographic location.

### Geohash

**Purpose**  
Convert **two-dimensional geographic coordinates** (latitude, longitude) into a **one-dimensional index** that supports efficient proximity queries.

**Where It’s Used**

- Can be stored and queried in **any database** that supports string or prefix-based indexing.
- Common in location-based services (LBS), search, and recommendation systems.

**How Geohash Works**

First, it divides the world into four quadrants along the prime meridian and the equator. These four quadrants are represented by two bits.  For the first bit, the left half is zero, and the right half is one. For the second bit, the top half is one, and the bottom half is zero.(左零右一，下零上一）
Instead of using the long series of 1s and 0s to represent the geohash, it is encoded as a base32 string.
The base32-encoded string length determines the size of the grid. These are called precisions or levels. There are 12 of these levels. For the location-based service, we are only interested in lengths 4 to 6. For anything longer than 6,  the grid size is too small. If it is smaller than 4, the grid size is too large. 
Now, how do we choose the right precision given a search radius? We want to find the minimal geohash length that covers the whole circle. For example, if the radius is 2km, the geohash length should be 5.



**Edge Cases and Boundary Issues**

#### Geohash boundary pitfalls ####
- Adjacent grids may be geographically close but share **no common prefix**.
- Two locations can share a long prefix yet fall into **different grids**.

Mitigation: Query the current grid plus its eight neighbors; neighbor geohashes are computable in constant time via common libraries.

#### Density considerations #### 
- city vs rural areas => you wanna use more granular grids for dense areas while use larger grids for sparse ones

## Quadtree

---
